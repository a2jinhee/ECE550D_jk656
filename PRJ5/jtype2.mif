-- J-Type Instructions Test Only
DEPTH = 4096;
WIDTH = 32;
ADDRESS_RADIX = DEC;
DATA_RADIX = BIN;
CONTENT
BEGIN
    -- nop
0000 : 00000000000000000000000000000000;
    
    -- 初始化几个寄存器
    -- addi $1, $0, 100        # r1 = 100
0001 : 00101000010000000000000001100100;
    -- addi $2, $0, 200        # r2 = 200
0002 : 00101000100000000000000011001000;
    
    -- ========== Test 1: j instruction ==========
    -- j 10                    # jump to address 10
0003 : 00001000000000000000000000001010;
    -- addi $3, $0, 111        # should be skipped
0004 : 00101000110000000000000001101111;
    -- addi $3, $0, 222        # should be skipped
0005 : 00101000110000000000000011011110;
    -- addi $3, $0, 333        # should be skipped
0006 : 00101000110000000000000101001101;
    -- addi $3, $0, 444        # should be skipped
0007 : 00101000110000000000000110111100;
    -- addi $3, $0, 555        # should be skipped
0008 : 00101000110000000000001000101011;
    -- addi $3, $0, 666        # should be skipped
0009 : 00101000110000000000001010011010;
    
    -- addi $3, $0, 50         # r3 = 50 (j lands here)
0010 : 00101000110000000000000000110010;
    
    -- ========== Test 2: jal instruction ==========
    -- jal 15                  # jump to 15, r31 = 12 (PC+1)
0011 : 00011000000000000000000000001111;
    -- addi $4, $0, 11         # r4 = 11 (execute after return)
0012 : 00101001000000000000000000001011;
    -- j 20                    # jump to end
0013 : 00001000000000000000000000010100;
    -- nop
0014 : 00000000000000000000000000000000;
    
    -- Function at address 15
    -- addi $5, $0, 77         # r5 = 77
0015 : 00101001010000000000000001001101;
    -- add $6, $1, $2          # r6 = 100 + 200 = 300
0016 : 00000001100000010100000000000000;
    -- jr $31                  # return to address 12
0017 : 00100111110000000000000000000000;
    -- nop
0018 : 00000000000000000000000000000000;
    -- nop
0019 : 00000000000000000000000000000000;
    
    -- ========== Test 3: bne instruction ==========
    -- addi $7, $0, 10         # r7 = 10
0020 : 00101001110000000000000000001010;
    -- addi $8, $0, 20         # r8 = 20
0021 : 00101010000000000000000000010100;
    -- bne $7, $8, 3           # 10 != 20, branch to 25
0022 : 00010001110100000000000000000011;
    -- addi $9, $0, 999        # should be skipped
0023 : 00101010010000000000001111100111;
    -- addi $9, $0, 888        # should be skipped
0024 : 00101010010000000000001101111000;
    
    -- addi $9, $0, 33         # r9 = 33 (after branch)
0025 : 00101010010000000000000000100001;
    -- bne $7, $7, 5           # 10 == 10, no branch
0026 : 00010001110011100000000000000101;
    -- addi $10, $0, 44        # r10 = 44 (should execute)
0027 : 00101010100000000000000000101100;
    
    -- ========== Test 4: blt instruction ==========
    -- addi $11, $0, 5         # r11 = 5
0028 : 00101010110000000000000000000101;
    -- addi $12, $0, 15        # r12 = 15
0029 : 00101011000000000000000000001111;
    -- blt $11, $12, 3         # 5 < 15, branch to 33
0030 : 00110010110110000000000000000011;
    -- addi $13, $0, 777       # should be skipped
0031 : 00101011010000000000001100001001;
    -- addi $13, $0, 666       # should be skipped
0032 : 00101011010000000000001010011010;
    
    -- addi $13, $0, 55        # r13 = 55 (after branch)
0033 : 00101011010000000000000000110111;
    -- blt $12, $11, 5         # 15 < 5? No
0034 : 00110011000101100000000000000101;
    -- addi $14, $0, 66        # r14 = 66 (should execute)
0035 : 00101011100000000000000001000010;
    
    -- ========== Test 5: setx and bex ==========
    -- setx 100                # r30 = 100
0036 : 10101000000000000000000001100100;
    -- bex 3                   # r30 != 0, branch to 40
0037 : 10110000000000000000000000000011;
    -- addi $15, $0, 123       # should be skipped
0038 : 00101011110000000000000001111011;
    -- addi $15, $0, 456       # should be skipped
0039 : 00101011110000000000000111001000;
    
    -- addi $15, $0, 88        # r15 = 88 (after bex)
0040 : 00101011110000000000000001011000;
    -- setx 0                  # r30 = 0
0041 : 10101000000000000000000000000000;
    -- bex 10                  # r30 == 0, no branch
0042 : 10110000000000000000000000001010;
    -- addi $16, $0, 99        # r16 = 99 (should execute)
0043 : 00101100000000000000000001100011;
    
    -- ========== Test 6: Exception + bex ==========
    -- addi $17, $0, 32767     # r17 = 32767 (0x7FFF)
0044 : 00101100010000000111111111111111;
    -- addi $18, $17, 1        # overflow! r30 = 2
0045 : 00101100100100010000000000000001;
    -- bex 3                   # r30 = 2 != 0, branch to 49
0046 : 10110000000000000000000000000011;
    -- addi $19, $0, 321       # should be skipped
0047 : 00101100110000000000000101000001;
    -- addi $19, $0, 654       # should be skipped
0048 : 00101100110000000000001010001110;
    
    -- addi $19, $0, 111       # r19 = 111 (after bex)
0049 : 00101100110000000000000001101111;
    
    -- Final instruction
    -- addi $20, $0, 255       # r20 = 255
0050 : 00101101000000000000000011111111;

[0051 .. 4095] : 00000000000000000000000000000000;
END;